{"title":"Gap Challenge Solver","markdown":{"yaml":{"title":"Gap Challenge Solver","description":"A Computer Vision powered solver for the 'Gap' puzzle using OpenCV and Backtracking algorithms.","author":"Jordan Chong","date":"2025-02-03","categories":["Computer Vision","Python","Streamlit","Algorithms","featured"],"image":"featured.png","body-class":"project-detail-view","include-before-body":{"text":"<div style='margin-top: 50px;'></div>"}},"headingText":"Overview","containsRefs":false,"markdown":"\n\n![](https://img.shields.io/badge/Python-3.10-3776AB?logo=python&logoColor=white)\n![](https://img.shields.io/badge/Status-Completed-success)\n[![GitHub](https://img.shields.io/badge/View_Source_Code-181717?logo=github&logoColor=white)](https://github.com/yourname/repo)\n\n<style>\n  #quarto-margin-sidebar {\n    padding-top: 50px; /* Match this to your header margin */\n  }\n</style>\n\n\nI built this application to solve the \"Gap\" puzzle—a logic game where players must deduce a missing symbol in a grid based on the rule that no symbol can repeat in any row or column.\n\nThe tool allows users to simply paste a screenshot of the puzzle. It then uses **Computer Vision** to \"read\" the grid and a **Recursive Backtracking** algorithm to solve it mathematically.\n\n::: {.callout-note}\n### Live Demo\nYou can interact with the embedded app below or view it in full screen [here](https://gap-solver-app.streamlit.app/).\n:::\n\n---\n\n## Technical Implementation\n\nThe solution is a two-step pipeline: **Digitization** (turning pixels into data) and **Solving** (finding the missing variable).\n\n### 1. Computer Vision Pipeline (OpenCV)\nBefore we can solve the puzzle, we must convert the raw image into a 2D matrix. I utilized `OpenCV` to perform the following steps:\n\n1.  **Grid Extraction:** The image is converted to grayscale and passed through a Canny edge detector. I use `cv2.findContours` to locate the individual cells of the grid based on their aspect ratio and area.\n2.  **Shape Classification:** For every cell, the algorithm isolates the inner shape and calculates geometric properties to classify it.\n    * **Solidity & Convexity:** Used to distinguish solid shapes (Square, Circle) from irregular ones (Stars, Crosses).\n    * **Vertex Counting:** `cv2.approxPolyDP` approximates the contour to a polygon. A shape with 3 vertices is a Triangle; 4 is a Square, etc.\n\n```python\n# Snippet: Logic for distinguishing similar shapes\nif is_convex or solidity > 0.92:\n    if vertices == 4: return \"3square\"\n    elif vertices == 3: return \"2triangle\"\n    else: return \"1circle\"\nelse:\n    # Stars have many vertices (tips + inner corners)\n    if 9 <= vertices <= 10: return \"5star\"\n```\n\n2. The Backtracking Algorithm\nOnce the grid is digitized, the problem becomes a Constraint Satisfaction Problem (CSP). I implemented a Recursive Backtracking algorithm, which is the standard approach for solving puzzles like Sudoku or N-Queens.\n\nHow it Works\nThe algorithm explores the search space using Depth-First Search (DFS):\n\nFind Empty: The solver scans the grid for the first empty cell (or the '?' cell).\n\nGenerate Candidates: It identifies the \"Universe\" of valid shapes (e.g., Circle, Square, Star) present in the puzzle.\n\nCheck Constraints: It attempts to place a candidate shape into the empty cell. It immediately checks: Does this shape already exist in this Row? Does it exist in this Column?\n\nRecurse: If the constraint check passes, it tentatively places the shape and calls itself recursively to solve the next empty cell.\n\nBacktrack: If the recursive call returns False (meaning the guess led to a dead end), the algorithm resets the cell to blank and tries the next candidate shape.\n\nThis ensures that we find a mathematically valid solution efficiently, rather than guessing randomly.\n\n```python\ndef solve_with_backtracking(board, all_shapes):\n    # 1. Base Case: If no empty spots are left, we are done.\n    find = find_empty(board)\n    if not find: return True \n    row, col = find\n    \n    # 2. Try every possible shape\n    for shape in all_shapes:\n        # 3. Check Constraints (Row & Column uniqueness)\n        if is_valid_move(board, shape, row, col):\n            \n            # 4. Place shape and Recurse\n            board[row][col] = shape\n            if solve_with_backtracking(board, all_shapes): \n                return True\n            \n            # 5. Backtrack (Reset if the path failed)\n            board[row][col] = 'blank'\n            \n    return False\n```\n\n\n3. Handling Sparse Data\nA unique challenge of this specific puzzle is that sometimes not all shapes are visible in the initial grid (e.g., a 5x5 grid might only show 3 types of shapes initially).\n\nTo make the solver robust, I implemented a logic check that forces the \"Universe\" of shapes to match the grid size. If the grid is 5x5 but only contains Circles and Squares, the system injects standard shapes (Triangles, Crosses, Stars) into the candidate list to ensure a solution is mathematically possible.\n\nTech Stack\nPython 3.10\n\nOpenCV: Image processing and contour detection.\n\nNumPy: Matrix manipulation.\n\nStreamlit: Frontend UI and state management for the interactive web app.","srcMarkdownNoYaml":"\n\n![](https://img.shields.io/badge/Python-3.10-3776AB?logo=python&logoColor=white)\n![](https://img.shields.io/badge/Status-Completed-success)\n[![GitHub](https://img.shields.io/badge/View_Source_Code-181717?logo=github&logoColor=white)](https://github.com/yourname/repo)\n\n<style>\n  #quarto-margin-sidebar {\n    padding-top: 50px; /* Match this to your header margin */\n  }\n</style>\n\n## Overview\n\nI built this application to solve the \"Gap\" puzzle—a logic game where players must deduce a missing symbol in a grid based on the rule that no symbol can repeat in any row or column.\n\nThe tool allows users to simply paste a screenshot of the puzzle. It then uses **Computer Vision** to \"read\" the grid and a **Recursive Backtracking** algorithm to solve it mathematically.\n\n::: {.callout-note}\n### Live Demo\nYou can interact with the embedded app below or view it in full screen [here](https://gap-solver-app.streamlit.app/).\n:::\n\n---\n\n## Technical Implementation\n\nThe solution is a two-step pipeline: **Digitization** (turning pixels into data) and **Solving** (finding the missing variable).\n\n### 1. Computer Vision Pipeline (OpenCV)\nBefore we can solve the puzzle, we must convert the raw image into a 2D matrix. I utilized `OpenCV` to perform the following steps:\n\n1.  **Grid Extraction:** The image is converted to grayscale and passed through a Canny edge detector. I use `cv2.findContours` to locate the individual cells of the grid based on their aspect ratio and area.\n2.  **Shape Classification:** For every cell, the algorithm isolates the inner shape and calculates geometric properties to classify it.\n    * **Solidity & Convexity:** Used to distinguish solid shapes (Square, Circle) from irregular ones (Stars, Crosses).\n    * **Vertex Counting:** `cv2.approxPolyDP` approximates the contour to a polygon. A shape with 3 vertices is a Triangle; 4 is a Square, etc.\n\n```python\n# Snippet: Logic for distinguishing similar shapes\nif is_convex or solidity > 0.92:\n    if vertices == 4: return \"3square\"\n    elif vertices == 3: return \"2triangle\"\n    else: return \"1circle\"\nelse:\n    # Stars have many vertices (tips + inner corners)\n    if 9 <= vertices <= 10: return \"5star\"\n```\n\n2. The Backtracking Algorithm\nOnce the grid is digitized, the problem becomes a Constraint Satisfaction Problem (CSP). I implemented a Recursive Backtracking algorithm, which is the standard approach for solving puzzles like Sudoku or N-Queens.\n\nHow it Works\nThe algorithm explores the search space using Depth-First Search (DFS):\n\nFind Empty: The solver scans the grid for the first empty cell (or the '?' cell).\n\nGenerate Candidates: It identifies the \"Universe\" of valid shapes (e.g., Circle, Square, Star) present in the puzzle.\n\nCheck Constraints: It attempts to place a candidate shape into the empty cell. It immediately checks: Does this shape already exist in this Row? Does it exist in this Column?\n\nRecurse: If the constraint check passes, it tentatively places the shape and calls itself recursively to solve the next empty cell.\n\nBacktrack: If the recursive call returns False (meaning the guess led to a dead end), the algorithm resets the cell to blank and tries the next candidate shape.\n\nThis ensures that we find a mathematically valid solution efficiently, rather than guessing randomly.\n\n```python\ndef solve_with_backtracking(board, all_shapes):\n    # 1. Base Case: If no empty spots are left, we are done.\n    find = find_empty(board)\n    if not find: return True \n    row, col = find\n    \n    # 2. Try every possible shape\n    for shape in all_shapes:\n        # 3. Check Constraints (Row & Column uniqueness)\n        if is_valid_move(board, shape, row, col):\n            \n            # 4. Place shape and Recurse\n            board[row][col] = shape\n            if solve_with_backtracking(board, all_shapes): \n                return True\n            \n            # 5. Backtrack (Reset if the path failed)\n            board[row][col] = 'blank'\n            \n    return False\n```\n\n\n3. Handling Sparse Data\nA unique challenge of this specific puzzle is that sometimes not all shapes are visible in the initial grid (e.g., a 5x5 grid might only show 3 types of shapes initially).\n\nTo make the solver robust, I implemented a logic check that forces the \"Universe\" of shapes to match the grid size. If the grid is 5x5 but only contains Circles and Squares, the system injects standard shapes (Triangles, Crosses, Stars) into the candidate list to ensure a solution is mathematically possible.\n\nTech Stack\nPython 3.10\n\nOpenCV: Image processing and contour detection.\n\nNumPy: Matrix manipulation.\n\nStreamlit: Frontend UI and state management for the interactive web app."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"include-before-body":{"text":"<div style='margin-top: 50px;'></div>"},"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","theme":"cosmo","title":"Gap Challenge Solver","description":"A Computer Vision powered solver for the 'Gap' puzzle using OpenCV and Backtracking algorithms.","author":"Jordan Chong","date":"2025-02-03","categories":["Computer Vision","Python","Streamlit","Algorithms","featured"],"image":"featured.png","body-class":"project-detail-view"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}