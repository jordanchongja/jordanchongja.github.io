<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jordan Chong">
<meta name="dcterms.date" content="2025-02-09">
<meta name="description" content="Evolution of a Computer Vision pipeline: From brittle Template Matching to robust SVMs, integrated with a Backtracking solver.">

<title>Gap Challenge Solver – Jordan’s Projects</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../..//assets/favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-443253e461b1d6f7d52c3923baf43cc1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V7YLYPVKHH"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-V7YLYPVKHH', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Gap Challenge Solver – Jordan’s Projects">
<meta property="og:description" content="Evolution of a Computer Vision pipeline: From brittle Template Matching to robust SVMs, integrated with a Backtracking solver.">
<meta property="og:image" content="https://jordanchongja.github.io/projects/gap-challenge-solver/featured.png">
<meta property="og:site_name" content="Jordan's Projects">
<meta property="og:image:height" content="274">
<meta property="og:image:width" content="281">
<meta property="og:image:alt" content="Screenshot of the dashboard">
<meta name="twitter:title" content="Gap Challenge Solver – Jordan’s Projects">
<meta name="twitter:description" content="Evolution of a Computer Vision pipeline: From brittle Template Matching to robust SVMs, integrated with a Backtracking solver.">
<meta name="twitter:image" content="https://jordanchongja.github.io/projects/gap-challenge-solver/featured.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image-height" content="274">
<meta name="twitter:image-width" content="281">
<meta name="twitter:image:alt" content="Screenshot of the dashboard">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jordan’s Projects</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../projects/index.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../readings/index.html"> 
<span class="menu-text">Readings</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../assets/Jordan_Chong_CV.pdf" target="_blank"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jordan-chong-88a02b172/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jordanchongja"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-challenge" id="toc-the-challenge" class="nav-link active" data-scroll-target="#the-challenge">The Challenge</a>
  <ul class="collapse">
  <li><a href="#major-problem-faced-with-image-recognition" id="toc-major-problem-faced-with-image-recognition" class="nav-link" data-scroll-target="#major-problem-faced-with-image-recognition">Major Problem Faced with Image Recognition</a></li>
  </ul></li>
  <li><a href="#act-i-the-naive-approach-template-matching" id="toc-act-i-the-naive-approach-template-matching" class="nav-link" data-scroll-target="#act-i-the-naive-approach-template-matching">Act I: The Naive Approach (Template Matching)</a>
  <ul class="collapse">
  <li><a href="#the-cause-of-failure" id="toc-the-cause-of-failure" class="nav-link" data-scroll-target="#the-cause-of-failure">The Cause of Failure</a></li>
  </ul></li>
  <li><a href="#act-ii-the-geometric-pivot-heuristics" id="toc-act-ii-the-geometric-pivot-heuristics" class="nav-link" data-scroll-target="#act-ii-the-geometric-pivot-heuristics">Act II: The Geometric Pivot (Heuristics)</a>
  <ul class="collapse">
  <li><a href="#the-live-scanner-debugger" id="toc-the-live-scanner-debugger" class="nav-link" data-scroll-target="#the-live-scanner-debugger">The “Live Scanner” Debugger</a></li>
  <li><a href="#the-bottleneck" id="toc-the-bottleneck" class="nav-link" data-scroll-target="#the-bottleneck">The Bottleneck</a></li>
  </ul></li>
  <li><a href="#act-iii-the-robust-solution-support-vector-machines" id="toc-act-iii-the-robust-solution-support-vector-machines" class="nav-link" data-scroll-target="#act-iii-the-robust-solution-support-vector-machines">Act III: The Robust Solution (Support Vector Machines)</a>
  <ul class="collapse">
  <li><a href="#the-data-pipeline-solving-distribution-shift" id="toc-the-data-pipeline-solving-distribution-shift" class="nav-link" data-scroll-target="#the-data-pipeline-solving-distribution-shift">1. The Data Pipeline (Solving Distribution Shift)</a></li>
  <li><a href="#the-universal-translator-preprocessing" id="toc-the-universal-translator-preprocessing" class="nav-link" data-scroll-target="#the-universal-translator-preprocessing">2. The “Universal Translator” (Preprocessing)</a></li>
  <li><a href="#fine-tuning-the-brain-grid-search" id="toc-fine-tuning-the-brain-grid-search" class="nav-link" data-scroll-target="#fine-tuning-the-brain-grid-search">3. Fine-Tuning the Brain (Grid Search)</a></li>
  <li><a href="#x-ray-vision-verification" id="toc-x-ray-vision-verification" class="nav-link" data-scroll-target="#x-ray-vision-verification">4. X-Ray Vision (Verification)</a></li>
  </ul></li>
  <li><a href="#the-solver-logic-backtracking" id="toc-the-solver-logic-backtracking" class="nav-link" data-scroll-target="#the-solver-logic-backtracking">The Solver Logic (Backtracking)</a></li>
  <li><a href="#conclusion-tech-stack" id="toc-conclusion-tech-stack" class="nav-link" data-scroll-target="#conclusion-tech-stack">Conclusion &amp; Tech Stack</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div style="margin-top: 50px;"></div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Gap Challenge Solver</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Computer Vision</div>
    <div class="quarto-category">Python</div>
    <div class="quarto-category">Streamlit</div>
    <div class="quarto-category">Algorithms</div>
    <div class="quarto-category">featured</div>
  </div>
  </div>

<div>
  <div class="description">
    Evolution of a Computer Vision pipeline: From brittle Template Matching to robust SVMs, integrated with a Backtracking solver.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jordan Chong </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 9, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><img src="https://img.shields.io/badge/Python-3.10-3776AB?logo=python&amp;logoColor=white" class="img-fluid"> <img src="https://img.shields.io/badge/Status-Completed-success.png" class="img-fluid"> <a href="https://github.com/jordanchongja/gap-solver-app"><img src="https://img.shields.io/badge/View_Source_Code-181717?logo=github&amp;logoColor=white.png" class="img-fluid" alt="GitHub"></a></p>
<p><span style="color: gray; font-size: 0.9em;"> Source idea credited to Dianyi Yang: <a href="https://github.com/kv9898/gap_challenge_solver">kv9898/gap_challenge_solver</a> </span></p>
<style>
  #quarto-margin-sidebar {
    padding-top: 50px; /* Match this to your header margin */
  }
</style>
<p>You can try the exercises yourself here:<br>
- <a href="https://www.gapchallenge.com/">Gap Challenge</a><br>
- <a href="https://switch-challenge-pratice.org/exercise/Aon/gapChallenge/test">Gap Challenge Practice</a></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Live Demo
</div>
</div>
<div class="callout-body-container callout-body">
<p>You can try the final SVM-powered solver here: <a href="https://gap-solver-application.streamlit.app/"><strong>Launch Streamlit App</strong></a></p>
</div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/0_success-streamlit-demo.gif" class="img-fluid figure-img"></p>
<figcaption>Demonstration of Streamlit Application</figcaption>
</figure>
</div>
<section id="the-challenge" class="level2">
<h2 class="anchored" data-anchor-id="the-challenge">The Challenge</h2>
<p>The “Gap” puzzle is a logic game where players must fill a missing cell in a grid, ensuring no symbol repeats in any row or column. My goal was to build a tool that could solve this instantly from a simple screenshot.</p>
<div class="quarto-layout-panel" data-layout="[[1,1], [1]]">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/1_gapchallenge_4.png" class="img-fluid figure-img"></p>
<figcaption>4x4 Grid</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/2_gapchallenge_5.png" class="img-fluid figure-img"></p>
<figcaption>5x5 Grid</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: flex-start;">
<p><strong>Gap Challenge</strong> - Each shape can only appear in a row or column once. The player must use logic by elimination to find the shape that belongs in the question mark.</p>
</div>
</div>
</div>
<p>While the logic puzzle itself is a standard Constraint Satisfaction Problem, <strong>digitizing the grid from a raw image</strong> proved to be the real engineering challenge. This post documents the three major iterations (“Acts”) of my Computer Vision pipeline and the lessons learned from each:</p>
<ul>
<li><strong>Act 1:</strong> Naive Template Matching<br>
</li>
<li><strong>Act 2:</strong> Geometric Determination of Shapes<br>
</li>
<li><strong>Act 3:</strong> Image Classification with SVM</li>
</ul>
<section id="major-problem-faced-with-image-recognition" class="level3">
<h3 class="anchored" data-anchor-id="major-problem-faced-with-image-recognition">Major Problem Faced with Image Recognition</h3>
<p>A major issue was the different forms that the shapes could take based on different Gap Challenge applications. Some shapes were hollow, some backgrounds were black and some bounding grids were just lines.</p>
<div class="quarto-layout-panel" data-layout="[[1,1,1], [1]]">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/3_normal_gap.png" class="img-fluid figure-img"></p>
<figcaption>Normal Version</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/3_line_gap.png" class="img-fluid figure-img"></p>
<figcaption>Line Version</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/3_dark_gap.png" class="img-fluid figure-img"></p>
<figcaption>Dark-mode Version</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: flex-start;">
<p>Note the difference in shapes and grid colors. The hard part was building a robust solution that would be able to handle all these different versions.</p>
</div>
</div>
</div>
<hr>
</section>
</section>
<section id="act-i-the-naive-approach-template-matching" class="level2">
<h2 class="anchored" data-anchor-id="act-i-the-naive-approach-template-matching">Act I: The Naive Approach (Template Matching)</h2>
<p>My first instinct was to use <strong>Template Matching</strong>. I cropped reference images of each shape (Star, Circle, Square) and used <code>cv2.matchTemplate</code> to slide them over the screenshot, looking for pixel-perfect matches. I tried to account for the different size of the screenshots as well, scaling the reference shapes to match the screenshots.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/3_template_screenshots.png" class="img-fluid figure-img"></p>
<figcaption>Reference Images used for template matching</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/4_similarity_matching.gif" class="img-fluid figure-img"></p>
<figcaption>Heatmap matching of the reference images. Green boxes show a &gt;90% match score against the reference image.</figcaption>
</figure>
</div>
<section id="the-cause-of-failure" class="level3">
<h3 class="anchored" data-anchor-id="the-cause-of-failure">The Cause of Failure</h3>
<p>This method worked well on the base example but failed when tested on other forms of the puzzle. Although I implemented multi-scale matching to handle zoom levels, the approach hit a hard ceiling when the puzzle’s <strong>visual style</strong> changed.</p>
<p>When the game switched to “Dark Mode” or used “Hollow” shapes, my solid-colored templates failed immediately. To fix this, I would have needed to crop and save a new template for every possible theme variation.</p>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/5_geometric_solver_fail_shapes.gif" class="img-fluid figure-img"></p>
<figcaption>Failure Case 1: Hollow Shapes</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/5_geometric_solver_fail_darkmode.gif" class="img-fluid figure-img"></p>
<figcaption>Failure Case 2: Dark Mode</figcaption>
</figure>
</div>
</div>
</div>
</div>
<blockquote class="blockquote">
<p><strong>Lesson:</strong> Hard-coding pixel comparisons doesn’t work if the inputs vary significantly. I needed a more robust method and decided to try and use the geometric differences in shapes to differentiate them.</p>
</blockquote>
<hr>
</section>
</section>
<section id="act-ii-the-geometric-pivot-heuristics" class="level2">
<h2 class="anchored" data-anchor-id="act-ii-the-geometric-pivot-heuristics">Act II: The Geometric Pivot (Heuristics)</h2>
<p>For the second iteration, I moved to <strong>Feature Extraction</strong>. Instead of matching images, I used <code>cv2.findContours</code> to extract the shapes and analyze their geometric properties.</p>
<p>I built a <strong>Decision Tree</strong> based on metrics like:<br>
- <strong>Vertices:</strong> <code>cv2.approxPolyDP</code> (e.g., 3 vertices = Triangle).<br>
- <strong>Solidity:</strong> Area divided by Convex Hull Area (distinguishes solid Squares from hollow Crosses).<br>
- <strong>Circularity:</strong> <span class="math inline">\(4\pi \times \frac{Area}{Perimeter^2}\)</span> (distinguishes Circles from Triangles).</p>
<section id="the-live-scanner-debugger" class="level3">
<h3 class="anchored" data-anchor-id="the-live-scanner-debugger">The “Live Scanner” Debugger</h3>
<p>To refine my thresholds, I built a visualization tool that calculated these metrics for every cell so that I could debug the errors efficiently.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/5_geometric_solver.gif" class="img-fluid figure-img"></p>
<figcaption>The Logic Dashboard. Watching the metrics update in real-time allowed me to tune the decision tree.</figcaption>
</figure>
</div>
</section>
<section id="the-bottleneck" class="level3">
<h3 class="anchored" data-anchor-id="the-bottleneck">The Bottleneck</h3>
<p>While robust against scale, this method suffered from “Whack-a-Mole” logic, where more issues would pop-up after fixing one and I realised I was trying to fix symptoms instead of fixing the root cause of the recognition issues:<br>
- <strong>The “Hollow” Edge Case:</strong> A hollow square has low solidity, confusing the algorithm.<br>
- <strong>The “Question Mark” Problem:</strong> The question mark consists of two separate blobs (hook + dot), breaking the single-contour logic.</p>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/6_error_question1.png" class="img-fluid figure-img"></p>
<figcaption>Failure Case: Hollow Shapes</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/7_error_darkmode1.png" class="img-fluid figure-img"></p>
<figcaption>Failure Case: Dark Mode</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>The “Whack-a-Mole” logic resulted in decision trees like:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Attempts to handle edge cases manually</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> vertices <span class="op">&gt;</span> <span class="dv">8</span> <span class="kw">and</span> circularity <span class="op">&lt;</span> <span class="fl">0.6</span> <span class="kw">and</span> num_blobs <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"Star"</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> num_blobs <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"Question"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This resulted in more and more rules that I wasn’t even sure of and I decided a needed a system to learn these rules itself.</p>
<hr>
</section>
</section>
<section id="act-iii-the-robust-solution-support-vector-machines" class="level2">
<h2 class="anchored" data-anchor-id="act-iii-the-robust-solution-support-vector-machines">Act III: The Robust Solution (Support Vector Machines)</h2>
<p>In the final phase, I treated this as a classification problem. I chose a <strong>Support Vector Machine (SVM)</strong> because they perform exceptionally well on high-dimensional binary data (pixel maps) with smaller datasets.</p>
<section id="the-data-pipeline-solving-distribution-shift" class="level3">
<h3 class="anchored" data-anchor-id="the-data-pipeline-solving-distribution-shift">1. The Data Pipeline (Solving Distribution Shift)</h3>
<p>A mistake that I made at the start was training on “perfect” data but testing on “messy” data.<br>
I manually took multiple screenshots of the grids, with minor variations, to create a large train dataset for the SVM.<br>
However, I realised that the SVM was not performing well, because the cropping method used for the test data was different from the perfectly cropped screenshots i was taking for the train data.</p>
<p>To fix this, I used the test cropping algorithm to build an automated pipeline (<code>collect_feedback_data.py</code>) that extracted thousands of training examples <strong>directly from screenshots</strong>.</p>
<p>This ensured my training data included all the real-world noise (grid lines, anti-aliasing) that the model would see in production. I utilized <strong>Otsu’s Binarization</strong> here to automatically find the optimal threshold for separating shapes from the background, solving the “Dark Mode” issue.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/8_success-testimages_extraction.gif" class="img-fluid figure-img"></p>
<figcaption>Automatic cropping and extraction of train data and grids for the SVM to train on.</figcaption>
</figure>
</div>
</section>
<section id="the-universal-translator-preprocessing" class="level3">
<h3 class="anchored" data-anchor-id="the-universal-translator-preprocessing">2. The “Universal Translator” (Preprocessing)</h3>
<p>To make the model immune to lighting changes and user cropping errors, I engineered a standardization pipeline: 1. <strong>Resize</strong> to 64x64.<br>
2. <strong>Corner Difference Strategy:</strong> Calculate the average background color from the image corners and subtract it. This isolates the shape regardless of whether the theme is Dark or Light.<br>
3. <strong>Centering:</strong> Find the bounding box of the shape and center it on a black canvas.</p>
</section>
<section id="fine-tuning-the-brain-grid-search" class="level3">
<h3 class="anchored" data-anchor-id="fine-tuning-the-brain-grid-search">3. Fine-Tuning the Brain (Grid Search)</h3>
<p>An SVM is only as good as its hyperparameters. Default settings often lead to overfitting, where the model memorizes the training data but fails on new inputs.</p>
<p>To solve this, I implemented a <strong>Grid Search</strong> to exhaustively test combinations of <code>C</code> (Regularization) and <code>Gamma</code> (Kernel Coefficient). This allowed me to mathematically find the configuration that ignored minor pixel noise while maintaining a distinct decision boundary between similar shapes (like the Circle and the hollow Ring).</p>
</section>
<section id="x-ray-vision-verification" class="level3">
<h3 class="anchored" data-anchor-id="x-ray-vision-verification">4. X-Ray Vision (Verification)</h3>
<p>Machine Learning models can be “black boxes.” To trust the system, I built a side-by-side debugger comparing the <strong>Human View</strong> (RGB) against the <strong>Machine View</strong> (Preprocessed). This allowed me to catch preprocessing errors—like the dot of the ‘?’ being filtered out as noise—before retraining the model.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/8_success-svm_view.gif" class="img-fluid figure-img"></p>
<figcaption>SVM Debugger. Left is the game input; Right is what the model actually sees.</figcaption>
</figure>
</div>
<hr>
</section>
</section>
<section id="the-solver-logic-backtracking" class="level2">
<h2 class="anchored" data-anchor-id="the-solver-logic-backtracking">The Solver Logic (Backtracking)</h2>
<p>With a reliable Vision pipeline returning a 2D matrix (e.g., <code>[['Star', 'Empty'], ['Circle', 'Square']]</code>), the problem reduced to a standard algorithm.</p>
<p>I implemented a <strong>Recursive Backtracking</strong> solver. It works by:<br>
1. <strong>Scanning</strong> for an empty cell.<br>
2. <strong>Guessing</strong> a shape from the available options.<br>
3. <strong>Validating</strong> row/column constraints.<br>
4. <strong>Recursively</strong> attempting to solve the rest of the grid.<br>
5. <strong>Backtracking</strong> if a guess leads to a contradiction.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve_with_backtracking(board, universe):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base Case: No empty spots left</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> find_empty(board): <span class="cf">return</span> <span class="va">True</span> </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    row, col <span class="op">=</span> find_empty(board)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> shape <span class="kw">in</span> universe:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_valid_move(board, shape, row, col):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            board[row][col] <span class="op">=</span> shape</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Recursive Step</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> solve_with_backtracking(board, universe): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Backtrack</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            board[row][col] <span class="op">=</span> <span class="st">'blank'</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
<section id="conclusion-tech-stack" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-tech-stack">Conclusion &amp; Tech Stack</h2>
<p>This project was a lesson in selecting the right tool for the job. While deep learning (CNNs) could have solved this, it would have been overkill for a 5-class problem. An SVM combined with robust <strong>Data Engineering</strong> provided a lightweight, instant, and highly accurate solution (99% accuracy on test set).</p>
<ul>
<li><strong>Language:</strong> Python 3.10</li>
<li><strong>Vision:</strong> OpenCV (Canny, Otsu’s Binarization, Contours)</li>
<li><strong>ML:</strong> Scikit-Learn (SVM, GridSearch)</li>
<li><strong>Frontend:</strong> Streamlit</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/jordanchongja\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><span class="p-1">Made with <a href="https://quarto.org/">Quarto</a>.</span></p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jordanchongja">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jordan-chong-88a02b172/">
      <i class="bi bi-linkedin" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:jordanchongjian25@gmail.com">
      <i class="bi bi-envelope" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item">
 |
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/jordanchongja/jordanchongja.github.io">
<p>Source</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../license.html">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../contact.html">
<p>Contact</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>