[
  {
    "objectID": "readings/index.html",
    "href": "readings/index.html",
    "title": "Readings & Reflections",
    "section": "",
    "text": "Order By\n      Default\n      \n        Subtitle\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nEast of Eden\n\n\n★★★★★\n\n\n\n\n\n\nJohn Steinbeck\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/sg-insurance-model/index.html#overview",
    "href": "projects/sg-insurance-model/index.html#overview",
    "title": "Project Title",
    "section": "Overview",
    "text": "Overview\nThe “So What”: Standard pricing models were too slow for high-frequency environments. This project implements a C++ accelerated pricer that handles 10,000 options/sec."
  },
  {
    "objectID": "projects/sg-insurance-model/index.html#the-problem",
    "href": "projects/sg-insurance-model/index.html#the-problem",
    "title": "Project Title",
    "section": "1. The Problem",
    "text": "1. The Problem\nContext: Briefly explain why this matters.\nExample: “Standard Monte Carlo simulations are too slow for real-time pricing…”"
  },
  {
    "objectID": "projects/sg-insurance-model/index.html#the-solution",
    "href": "projects/sg-insurance-model/index.html#the-solution",
    "title": "Project Title",
    "section": "2. The Solution",
    "text": "2. The Solution\nApproach: High-level summary of your strategy. * Metric: What did you optimize? (Speed, Accuracy, Sharpe Ratio) * Tech Stack: Python (NumPy, Pandas), C++, Docker."
  },
  {
    "objectID": "projects/sg-insurance-model/index.html#technical-implementation",
    "href": "projects/sg-insurance-model/index.html#technical-implementation",
    "title": "Project Title",
    "section": "3. Technical Implementation",
    "text": "3. Technical Implementation\n\n\n\n\n\n\nNoteKey Algorithm: Vectorization\n\n\n\nBy replacing the for loop with NumPy vectorization, we reduced execution time from 40s to 0.2s."
  },
  {
    "objectID": "projects/sg-insurance-model/index.html#results",
    "href": "projects/sg-insurance-model/index.html#results",
    "title": "Project Title",
    "section": "4. Results",
    "text": "4. Results\n\nPerformance: 50x speedup.\nImpact: Enables real-time strategy backtesting.\n\nView Source Code on GitHub →"
  },
  {
    "objectID": "projects/gap-challenge-solver/index.html",
    "href": "projects/gap-challenge-solver/index.html",
    "title": "Gap Challenge Solver",
    "section": "",
    "text": "Source idea credited to Dianyi Yang: kv9898/gap_challenge_solver\nYou can try the exercises yourself here:\n- Gap Challenge\n- Gap Challenge Practice"
  },
  {
    "objectID": "projects/gap-challenge-solver/index.html#the-challenge",
    "href": "projects/gap-challenge-solver/index.html#the-challenge",
    "title": "Gap Challenge Solver",
    "section": "The Challenge",
    "text": "The Challenge\nThe “Gap” puzzle is a logic game where players must fill a missing cell in a grid, ensuring no symbol repeats in any row or column. My goal was to build a tool that could solve this instantly from a simple screenshot.\n\n\n\n\n\n\n4x4 Grid\n\n\n\n\n\n\n\n5x5 Grid\n\n\n\n\n\n\nGap Challenge - Each shape can only appear in a row or column once. The player must use logic by elimination to find the shape that belongs in the question mark.\n\n\n\nWhile the logic puzzle itself is a standard Constraint Satisfaction Problem, digitizing the grid from a raw image proved to be the real engineering challenge. This post documents the three major iterations (“Acts”) of my Computer Vision pipeline and the lessons learned from each:\n\nAct 1: Naive Template Matching\n\nAct 2: Geometric Determination of Shapes\n\nAct 3: Image Classification with SVM\n\n\nMajor Problem Faced with Image Recognition\nA major issue was the different forms that the shapes could take based on different Gap Challenge applications. Some shapes were hollow, some backgrounds were black and some bounding grids were just lines.\n\n\n\n\n\n\nNormal Version\n\n\n\n\n\n\n\nLine Version\n\n\n\n\n\n\n\nDark-mode Version\n\n\n\n\n\n\nNote the difference in shapes and grid colors. The hard part was building a robust solution that would be able to handle all these different versions."
  },
  {
    "objectID": "projects/gap-challenge-solver/index.html#act-i-the-naive-approach-template-matching",
    "href": "projects/gap-challenge-solver/index.html#act-i-the-naive-approach-template-matching",
    "title": "Gap Challenge Solver",
    "section": "Act I: The Naive Approach (Template Matching)",
    "text": "Act I: The Naive Approach (Template Matching)\nMy first instinct was to use Template Matching. I cropped reference images of each shape (Star, Circle, Square) and used cv2.matchTemplate to slide them over the screenshot, looking for pixel-perfect matches. I tried to account for the different size of the screenshots as well, scaling the reference shapes to match the screenshots.\n\n\n\nReference Images used for template matching\n\n\n\n\n\nHeatmap matching of the reference images. Green boxes show a &gt;90% match score against the reference image.\n\n\n\nThe Cause of Failure\nThis method worked well on the base example but failed when tested on other forms of the puzzle. Although I implemented multi-scale matching to handle zoom levels, the approach hit a hard ceiling when the puzzle’s visual style changed.\nWhen the game switched to “Dark Mode” or used “Hollow” shapes, my solid-colored templates failed immediately. To fix this, I would have needed to crop and save a new template for every possible theme variation.\n\n\n\n\n\n\nFailure Case 1: Hollow Shapes\n\n\n\n\n\n\n\nFailure Case 2: Dark Mode\n\n\n\n\n\n\nLesson: Hard-coding pixel comparisons doesn’t work if the inputs vary significantly. I needed a more robust method and decided to try and use the geometric differences in shapes to differentiate them."
  },
  {
    "objectID": "projects/gap-challenge-solver/index.html#act-ii-the-geometric-pivot-heuristics",
    "href": "projects/gap-challenge-solver/index.html#act-ii-the-geometric-pivot-heuristics",
    "title": "Gap Challenge Solver",
    "section": "Act II: The Geometric Pivot (Heuristics)",
    "text": "Act II: The Geometric Pivot (Heuristics)\nFor the second iteration, I moved to Feature Extraction. Instead of matching images, I used cv2.findContours to extract the shapes and analyze their geometric properties.\nI built a Decision Tree based on metrics like:\n- Vertices: cv2.approxPolyDP (e.g., 3 vertices = Triangle).\n- Solidity: Area divided by Convex Hull Area (distinguishes solid Squares from hollow Crosses).\n- Circularity: \\(4\\pi \\times \\frac{Area}{Perimeter^2}\\) (distinguishes Circles from Triangles).\n\nThe “Live Scanner” Debugger\nTo refine my thresholds, I built a visualization tool that calculated these metrics for every cell so that I could debug the errors efficiently.\n\n\n\nThe Logic Dashboard. Watching the metrics update in real-time allowed me to tune the decision tree.\n\n\n\n\nThe Bottleneck\nWhile robust against scale, this method suffered from “Whack-a-Mole” logic, where more issues would pop-up after fixing one and I realised I was trying to fix symptoms instead of fixing the root cause of the recognition issues:\n- The “Hollow” Edge Case: A hollow square has low solidity, confusing the algorithm.\n- The “Question Mark” Problem: The question mark consists of two separate blobs (hook + dot), breaking the single-contour logic.\n\n\n\n\n\n\nFailure Case: Hollow Shapes\n\n\n\n\n\n\n\nFailure Case: Dark Mode\n\n\n\n\n\nThe “Whack-a-Mole” logic resulted in decision trees like:\n# Attempts to handle edge cases manually\nif vertices &gt; 8 and circularity &lt; 0.6 and num_blobs == 1:\n    return \"Star\"\nelif num_blobs == 2:\n    return \"Question\"\nThis resulted in more and more rules that I wasn’t even sure of and I decided a needed a system to learn these rules itself."
  },
  {
    "objectID": "projects/gap-challenge-solver/index.html#act-iii-the-robust-solution-support-vector-machines",
    "href": "projects/gap-challenge-solver/index.html#act-iii-the-robust-solution-support-vector-machines",
    "title": "Gap Challenge Solver",
    "section": "Act III: The Robust Solution (Support Vector Machines)",
    "text": "Act III: The Robust Solution (Support Vector Machines)\nIn the final phase, I treated this as a classification problem. I chose a Support Vector Machine (SVM) because they perform exceptionally well on high-dimensional binary data (pixel maps) with smaller datasets.\n\n1. The Data Pipeline (Solving Distribution Shift)\nA mistake that I made at the start was training on “perfect” data but testing on “messy” data.\nI manually took multiple screenshots of the grids, with minor variations, to create a large train dataset for the SVM.\nHowever, I realised that the SVM was not performing well, because the cropping method used for the test data was different from the perfectly cropped screenshots i was taking for the train data.\nTo fix this, I used the test cropping algorithm to build an automated pipeline (collect_feedback_data.py) that extracted thousands of training examples directly from screenshots.\nThis ensured my training data included all the real-world noise (grid lines, anti-aliasing) that the model would see in production. I utilized Otsu’s Binarization here to automatically find the optimal threshold for separating shapes from the background, solving the “Dark Mode” issue.\n\n\n\nAutomatic cropping and extraction of train data and grids for the SVM to train on.\n\n\n\n\n2. The “Universal Translator” (Preprocessing)\nTo make the model immune to lighting changes and user cropping errors, I engineered a standardization pipeline: 1. Resize to 64x64.\n2. Corner Difference Strategy: Calculate the average background color from the image corners and subtract it. This isolates the shape regardless of whether the theme is Dark or Light.\n3. Centering: Find the bounding box of the shape and center it on a black canvas.\n\n\n3. Fine-Tuning the Brain (Grid Search)\nAn SVM is only as good as its hyperparameters. Default settings often lead to overfitting, where the model memorizes the training data but fails on new inputs.\nTo solve this, I implemented a Grid Search to exhaustively test combinations of C (Regularization) and Gamma (Kernel Coefficient). This allowed me to mathematically find the configuration that ignored minor pixel noise while maintaining a distinct decision boundary between similar shapes (like the Circle and the hollow Ring).\n\n\n4. X-Ray Vision (Verification)\nMachine Learning models can be “black boxes.” To trust the system, I built a side-by-side debugger comparing the Human View (RGB) against the Machine View (Preprocessed). This allowed me to catch preprocessing errors—like the dot of the ‘?’ being filtered out as noise—before retraining the model.\n\n\n\nSVM Debugger. Left is the game input; Right is what the model actually sees."
  },
  {
    "objectID": "projects/gap-challenge-solver/index.html#the-solver-logic-backtracking",
    "href": "projects/gap-challenge-solver/index.html#the-solver-logic-backtracking",
    "title": "Gap Challenge Solver",
    "section": "The Solver Logic (Backtracking)",
    "text": "The Solver Logic (Backtracking)\nWith a reliable Vision pipeline returning a 2D matrix (e.g., [['Star', 'Empty'], ['Circle', 'Square']]), the problem reduced to a standard algorithm.\nI implemented a Recursive Backtracking solver. It works by:\n1. Scanning for an empty cell.\n2. Guessing a shape from the available options.\n3. Validating row/column constraints.\n4. Recursively attempting to solve the rest of the grid.\n5. Backtracking if a guess leads to a contradiction.\ndef solve_with_backtracking(board, universe):\n    # Base Case: No empty spots left\n    if not find_empty(board): return True \n    \n    row, col = find_empty(board)\n    \n    for shape in universe:\n        if is_valid_move(board, shape, row, col):\n            board[row][col] = shape\n            # Recursive Step\n            if solve_with_backtracking(board, universe): return True\n            # Backtrack\n            board[row][col] = 'blank'\n            \n    return False"
  },
  {
    "objectID": "projects/gap-challenge-solver/index.html#conclusion-tech-stack",
    "href": "projects/gap-challenge-solver/index.html#conclusion-tech-stack",
    "title": "Gap Challenge Solver",
    "section": "Conclusion & Tech Stack",
    "text": "Conclusion & Tech Stack\nThis project was a lesson in selecting the right tool for the job. While deep learning (CNNs) could have solved this, it would have been overkill for a 5-class problem. An SVM combined with robust Data Engineering provided a lightweight, instant, and highly accurate solution (99% accuracy on test set).\n\nLanguage: Python 3.10\nVision: OpenCV (Canny, Otsu’s Binarization, Contours)\nML: Scikit-Learn (SVM, GridSearch)\nFrontend: Streamlit"
  },
  {
    "objectID": "notes/index.html",
    "href": "notes/index.html",
    "title": "Technical Notes",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nConcept: The Heston Model\n\n\n\nStochastic Calculus\n\nVolatility\n\nOptions\n\n\n\nDeriving the stochastic volatility model and calibrating it to market data.\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jordan Chong",
    "section": "",
    "text": "LinkedIn\n  \n  \n    \n     Github\n  \n  \n    \n     Email\n  \n  \n    \n     CV\n  \n\n  \n  \nStudied at Singapore Management University (SMU), Bachelor of Business Administration (Finance) with Second Major in Data Science.\nPreviously worked in Debt Capital Markets at DBS Bank and Advanced Manufacturing Development at EDB.\nCurrently, I am focused on building robust pricing models, researching market microstructure, and applying ML algorithms to financial datasets.\n\n\n\n\n\nFeatured Projects\n\nView all projects →\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGap Challenge Solver\n\n\n\nComputer Vision\n\nPython\n\nStreamlit\n\nAlgorithms\n\nfeatured\n\n\n\nEvolution of a Computer Vision pipeline: From brittle Template Matching to robust SVMs, integrated with a Backtracking solver.\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "contact.html",
    "href": "contact.html",
    "title": "Contact",
    "section": "",
    "text": "Contact \n\n\n\n&lt;label for=\"full-name\" style=\"display: block; margin-bottom: 0.5em;\"&gt;Full Name&lt;/label&gt;\n&lt;input type=\"text\" id=\"full-name\" name=\"name\" required style=\"width: 100%; padding: 0.5em;\"&gt;\n\n\n&lt;label for=\"email-address\" style=\"display: block; margin-bottom: 0.5em;\"&gt;Email Address&lt;/label&gt;\n&lt;input type=\"email\" id=\"email-address\" name=\"_replyto\" required style=\"width: 100%; padding: 0.5em;\"&gt;\n\n\n&lt;label for=\"message\" style=\"display: block; margin-bottom: 0.5em;\"&gt;Message&lt;/label&gt;\n&lt;textarea id=\"message\" name=\"message\" rows=\"6\" required style=\"width: 100%; padding: 0.5em;\"&gt;&lt;/textarea&gt;\n\n\nSend Message"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Hello! I’m [Your Name]. This is where you can write a more detailed biography…"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "Jordan's Projects",
    "section": "",
    "text": "hello"
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "License",
    "section": "",
    "text": "The content on this website is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n\n\n\nCreative Commons License Logo"
  },
  {
    "objectID": "notes/posts/book-review-1/template.html#definition",
    "href": "notes/posts/book-review-1/template.html#definition",
    "title": "Concept: The Heston Model",
    "section": "Definition",
    "text": "Definition\nThe Heston model assumes that volatility itself is a stochastic process. The dynamics are given by the SDEs:\n\\[\ndS_t = \\mu S_t dt + \\sqrt{v_t} S_t dW_t^S\n\\] \\[\ndv_t = \\kappa (\\theta - v_t) dt + \\xi \\sqrt{v_t} dW_t^v\n\\]\nWhere: * \\(\\kappa\\): Mean reversion speed * \\(\\theta\\): Long-run variance"
  },
  {
    "objectID": "notes/posts/book-review-1/template.html#calibration-strategy",
    "href": "notes/posts/book-review-1/template.html#calibration-strategy",
    "title": "Concept: The Heston Model",
    "section": "Calibration Strategy",
    "text": "Calibration Strategy\nTo calibrate this to the S&P 500 smile, we minimize the squared error between model price \\(C_{model}\\) and market price \\(C_{market}\\):\n\\[\n\\min_{\\Theta} \\sum_{i} (C_{model}(K_i, T_i) - C_{market}(K_i, T_i))^2\n\\]"
  },
  {
    "objectID": "notes/posts/book-review-1/template.html#implementation-details",
    "href": "notes/posts/book-review-1/template.html#implementation-details",
    "title": "Concept: The Heston Model",
    "section": "Implementation Details",
    "text": "Implementation Details\nI implemented the pricing using the Fourier Transform method (Lewis, 2001) because it allows for semi-closed form solutions, which are significantly faster than Monte Carlo for calibration purposes."
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Projects",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nGap Challenge Solver\n\n\n\nComputer Vision\n\nPython\n\nStreamlit\n\nAlgorithms\n\nfeatured\n\n\n\nEvolution of a Computer Vision pipeline: From brittle Template Matching to robust SVMs, integrated with a Backtracking solver.\n\n\n\nFeb 9, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nProject Title\n\n\n\nQuant Finance\n\nPython\n\nOptimization\n\n\n\nA one-sentence hook: e.g., Reducing option pricing latency by 40% using C++. Optimization of X using Y, resulting in Z% efficiency gain.\n\n\n\nFeb 5, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "readings/East of Eden/template.html#summary",
    "href": "readings/East of Eden/template.html#summary",
    "title": "East of Eden",
    "section": "Summary",
    "text": "Summary\nA multi-generational saga retelling the biblical story of Cain and Abel…"
  },
  {
    "objectID": "readings/East of Eden/template.html#key-takeaways",
    "href": "readings/East of Eden/template.html#key-takeaways",
    "title": "East of Eden",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nTimshel: The Hebrew word meaning “Thou Mayest.” It signifies that humans have the choice to overcome sin; we are not condemned by our nature.\nInheritance: We are not bound by the sins of our fathers."
  },
  {
    "objectID": "readings/East of Eden/template.html#favorite-quotes",
    "href": "readings/East of Eden/template.html#favorite-quotes",
    "title": "East of Eden",
    "section": "Favorite Quotes",
    "text": "Favorite Quotes\n\n“And now that you don’t have to be perfect, you can be good.”"
  },
  {
    "objectID": "readings/East of Eden/template.html#reflection",
    "href": "readings/East of Eden/template.html#reflection",
    "title": "East of Eden",
    "section": "Reflection",
    "text": "Reflection\nThis book shifted my perspective on agency. In a deterministic world (or in a quantitative model), we assume inputs dictate outputs. Steinbeck argues for the “error term”—the human capacity to choose against the grain.c"
  }
]